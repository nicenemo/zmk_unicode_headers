#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
generate_unicode_headers.py

Generate C header files with Unicode constants for every code point.
The script expects no external data files – it pulls everything from the
`unicodedataplus` package (Unicode data).

Each block gets its own header under `generated_headers/`.
"""

import pathlib
import re
import sys
import unicodedataplus as ucp
from typing import Dict, List, Set, Tuple, Optional
from collections import namedtuple

# --------------------------------------------------------------------
# 1. Configuration ---------------------------------------------------
# --------------------------------------------------------------------

# The version is derived directly from the unicodedataplus package data
UNICODE_VERSION = ucp.unidata_version

# Dictionary to map common script/language names to two-letter prefixes (ISO codes or common abbreviations)
SCRIPT_ABBREVIATIONS: Dict[str, str] = {
    # ISO 639-1 Language Codes
    "GREEK": "EL",
    "LATIN": "LA",
    "ARABIC": "AR",
    "HEBREW": "HE",
    "THAI": "TH",
    "KHMER": "KM",
    "TIBETAN": "TB",
    
    # Common Script Abbreviations
    "CYRILLIC": "CY",
    "COPTIC": "CP",
    "DEVANAGARI": "DV",
    "BENGALI": "BN",
    "GUJARATI": "GJ",
    "GURMUKHI": "GK",
    "ORIYA": "OR",
    "TAMIL": "TM",
    "TELUGU": "TL",
    
    # Generic/Block Prefixes
    "GENERAL": "GN",
    "COMBINING": "CM",
    "SUPERSCRIPTS": "SS",
    "SUBSCRIPTS": "SB",
    "MATHEMATICAL": "MA",
    "MISCELLANEOUS": "MS",
    "ENCLOSED": "EN",
    "CJK": "CJK",
}

# --------------------------------------------------------------------
# 2. Helper: printable glyph ----------------------------------------
# --------------------------------------------------------------------

def printable_glyph(cp: int) -> Optional[str]:
    """Return a printable representation of *cp* or None if it is not printable."""
    try:
        ch = chr(cp)
    except ValueError:
        return None
        
    cat = ucp.category(ch)
    if cat[0] in ("C", "Z"):        # Control or Separator
        return None
    if not ch.isprintable():
        return None
    return ch


# --------------------------------------------------------------------
# 3. Helper: case partner --------------------------------------------
# --------------------------------------------------------------------

def find_case_partner(cp: int) -> Tuple[Optional[int], str]:
    """
    Return (partner_cp, partner_name). This function anchors only on the 
    lowercase letter (category 'Ll') and confirms its partner is uppercase 
    (category 'Lu'), bypassing strict reciprocal name/mapping checks to 
    correctly pair archaic characters.
    """
    ch = chr(cp)

    try:
        current_cat = ucp.category(ch)
        current_name = ucp.name(ch)
    except ValueError:
        return None, ""

    # 1. Anchor only on lowercase letters (Ll)
    if current_cat != 'Ll':
        return None, ""
    
    # 2. Find upper partner
    partner_str = ch.upper()

    # Check if a single, different character was returned
    if len(partner_str) == 1 and partner_str != ch:
        partner_cp = ord(partner_str)
        try:
            partner_cat = ucp.category(chr(partner_cp))
            partner_name = ucp.name(chr(partner_cp))
        except ValueError:
            return None, ""
        
        # 3. Confirm partner is an Uppercase Letter (Lu)
        if partner_cat == 'Lu':
            return partner_cp, partner_name

    return None, ""


# --------------------------------------------------------------------
# 4. Emit a single header file --------------------------------------
# --------------------------------------------------------------------

def emit_header(block_name: str,
                start_cp: int,
                end_cp: int,
                out_dir: pathlib.Path) -> None:
    """
    Write one header for the block.
    """
    # Sanitize file name
    file_basename = re.sub(r"\s+", "_", block_name).lower()
    if not re.match(r"^[a-z0-9_]+$", file_basename):
        file_basename = f"block_{start_cp:04X}"
    header_file = out_dir / f"{file_basename}.h"

    lines: List[str] = [
        f"/* {block_name}.h – Unicode constants for U+{start_cp:04X} … U+{end_cp:04X}",
        "*",
        f"* Generated by generate_unicode_headers.py (Unicode {UNICODE_VERSION})",
        "*",
        "* See https://www.unicode.org/versions/latest/ for source data.",
        "*/\n",
        "#pragma once\n"
    ]

    processed: Set[int] = set()

    for cp in range(start_cp, end_cp + 1):
        if cp in processed:
            continue
            
        try:
            name = ucp.name(chr(cp))
        except ValueError:
            # Skip unassigned or reserved code points.
            continue
            
        glyph = printable_glyph(cp)

        # find_case_partner only returns a match if cp is the lowercase anchor.
        partner_cp, partner_name = find_case_partner(cp)
        partner_glyph = printable_glyph(partner_cp) if partner_cp else None

        # --- PROCESSING STRATEGY ---
        
        # 1. Skip Capital Letters that defer to a later Lowercase partner
        is_capital_cat = ucp.category(chr(cp)) == 'Lu'

        # Check if the current character is an uppercase letter and has a single lowercase mapping
        lower_str = chr(cp).lower()
        if is_capital_cat and len(lower_str) == 1 and lower_str != chr(cp):
            lower_partner_cp = ord(lower_str)
            # If the lowercase partner comes later in the codepoint range, skip the capital
            # and let the lowercase letter define the pair later.
            if lower_partner_cp > cp:
                # CRITICAL FIX: DO NOT add cp to processed here. 
                # The lowercase partner must define the pair and mark BOTH as processed.
                continue
            
        # 2. SUCCESSFUL PAIR CASE (Only runs if cp is a Lowercase anchor)
        if partner_cp: 
            
            # Since find_case_partner only returns pairs anchored on the lowercase letter,
            # cp is the small letter (cp1) and partner_cp is the capital (cp2).
            cp1, cp2 = cp, partner_cp
            name1, name2 = name, partner_name
            glyph1, glyph2 = glyph, partner_glyph

            # Comment formatting change: Simplified glyph/glyph
            if glyph1 and glyph2:
                comment = f"// {glyph1}/{glyph2}"
            else:
                # Fallback to verbose style if glyphs are missing
                comment_parts = [f"U+{cp1:04X} ({name1})", f"U+{cp2:04X} ({name2})"]
                comment = f"/* {' '.join(comment_parts)} */"
            
            # Use short name (strip case prefix) for successful pairing
            lines.append(
                f"#define {macro_name_from_unicode_name(name1, strip_case=True):<40} 0x{cp1:04X} 0x{cp2:04X}  {comment}" 
            )
            # Mark both code points as processed
            processed.update({cp1, cp2})
            continue

        # 3. SINGLE CODE POINT CASE (Includes all non-paired/skipped cased letters and symbols)
        if cp not in processed:
            
            # Comment formatting change: Simplified glyph
            if glyph:
                comment = f"// {glyph}"
            else:
                # Fallback to verbose style if glyph is missing
                comment_parts = [f"U+{cp:04X} ({name})"]
                comment = f"/* {' '.join(comment_parts)} */"
            
            # Use long name (do not strip case prefix) for single entry to prevent collisions
            lines.append(
                f"#define {macro_name_from_unicode_name(name, strip_case=False):<40} 0x{cp:04X} 0  {comment}" 
            )
            processed.add(cp)

    header_file.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"Written {header_file}")


# --------------------------------------------------------------------
# 5. Convert a Unicode name into an identifier ----------------------
# --------------------------------------------------------------------

def macro_name_from_unicode_name(unicode_name: str, strip_case: bool) -> str:
    """
    Build a C‑identifier from the Unicode name, conditionally removing the case
    identifier, and abbreviating the script/language name.
    """
    s = unicode_name
    
    # 1. Remove case properties ONLY if requested (for successful pairs)
    if strip_case:
        s = re.sub(r"(SMALL|CAPITAL|LOWERCASE|UPPERCASE)\s", "", s)
    
    # 2. Convert to uppercase
    s_upper = s.upper()
    
    # 3. Try to find and replace the script/language prefix (e.g., GREEK -> EL)
    s_words = s_upper.split()
    if s_words and s_words[0] in SCRIPT_ABBREVIATIONS:
        # Replace the first word (script name) with its abbreviation
        abbr = SCRIPT_ABBREVIATIONS[s_words[0]]
        s_upper = abbr + ' ' + ' '.join(s_words[1:])
    
    # 4. Normalize (replace spaces/non-word characters with underscores)
    s_final = re.sub(r"[^\w]", "_", s_upper)
    s_final = re.sub(r"_+", "_", s_final)
    
    return f"UC_{s_final}"


def get_all_blocks():
    """
    Yields blocks with .name, .start, .end by probing unicodedataplus.
    """
    Block = namedtuple('Block', ['name', 'start', 'end'])
    
    current_name = None
    start_cp = 0
    
    # Iterate over the entire Unicode range
    for cp in range(0x110000):
        try:
            char = chr(cp)
            name = ucp.block(char)
        except Exception:
            name = "No_Block"
        
        if name != current_name:
            if current_name and current_name != "No_Block":
                yield Block(current_name, start_cp, cp - 1)
            current_name = name
            start_cp = cp
            
    if current_name and current_name != "No_Block":
        yield Block(current_name, start_cp, 0x10FFFF)
        
# --------------------------------------------------------------------
# 6. Main ---------------------------------------------------------------
# --------------------------------------------------------------------

def main() -> None:
    out_dir = pathlib.Path("generated_headers")
    out_dir.mkdir(exist_ok=True)

    # Build a list of (block_name, start_cp, end_cp) from the data in unicodedataplus
    blocks: List[Tuple[str, int, int]] = []
    for block in get_all_blocks():
        blocks.append((block.name, block.start, block.end))

    for block_name, start_cp, end_cp in blocks:
        emit_header(block_name, start_cp, end_cp, out_dir)

    print("\nAll headers written to", out_dir.resolve())


if __name__ == "__main__":
    sys.exit(main())
