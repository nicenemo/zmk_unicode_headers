#!/usr/bin/env python3
"""
generate_unicode_headers.py – HTTPS download with custom User‑Agent

Creates a header file for every Unicode block.
"""

import sys, re, pathlib, time, unicodedata

def get_file(name: str) -> pathlib.Path:
    """
    Return a local Path for *name*.
    If the file does not exist locally, raise RuntimeError instead of downloading it.
    """
    dest = pathlib.Path(name)
    if dest.is_file():
        return dest

    # File missing – bail out with an explicit message
    raise RuntimeError(
        f"Required data file '{name}' is missing. "
        "Please download it manually from the Unicode website and place it in the current directory."
    )

# --------------------------------------------------------------------
# Parsing helpers ---------------------------------------------------
# --------------------------------------------------------------------

def parse_blocks(blocks_file: pathlib.Path) -> list[tuple[str, int, int]]:
    """Return a list of (block_name, start_cp, end_cp)."""
    blocks = []
    for line in blocks_file.read_text(encoding="utf-8").splitlines():
        if not line or line.startswith("#"):
            continue
        range_part, name = line.split("; ", 1)
        start_str, end_str = range_part.split("..")
        start = int(start_str, 16)
        end   = int(end_str, 16)
        blocks.append((name.strip(), start, end))
    return blocks

def load_names(names_file: pathlib.Path) -> dict[int, str]:
    """Build a mapping code_point → Unicode name from UnicodeData.txt."""
    names = {}
    for line in names_file.read_text(encoding="utf-8").splitlines():
        if not line or line.startswith("#"):
            continue
        parts = line.split(";")
        if len(parts) < 2:
            continue
        code_str, name = parts[0].strip(), parts[1].strip()
        try:
            cp = int(code_str, 16)
        except ValueError:
            continue
        names[cp] = name
    return names

def macro_name_from_unicode_name(unicode_name: str) -> str:
    """Convert a Unicode name into an identifier like UC_HEBREW_LETTER_ALEF."""
    s = re.sub(r"[^\w]", "_", unicode_name.upper())
    s = re.sub(r"_+", "_", s)
    return f"UC_{s}"

def printable_glyph(cp: int) -> str | None:
    """Return the glyph for *cp* if it is printable; otherwise None."""
    cat = unicodedata.category(chr(cp))
    if cat[0] in ("C", "Z"):        # Control or Separator
        return None
    ch = chr(cp)
    if not ch.isprintable():
        return None
    return ch

# --------------------------------------------------------------------
# Header emission ---------------------------------------------------
# --------------------------------------------------------------------

def emit_header(block_name: str,
                start_cp: int,
                end_cp: int,
                names: dict[int, str],
                out_dir: pathlib.Path) -> None:
    """Write a header file for one block."""
    # File name derived from the block name
    file_basename = re.sub(r"\s+", "_", block_name).lower()
    if not re.match(r"^[a-z0-9_]+$", file_basename):
        file_basename = f"block_{start_cp:04X}"
    header_file = out_dir / f"{file_basename}.h"

    lines = [
        f"/* {block_name}.h – Unicode constants for U+{start_cp:04X} … U+{end_cp:04X}",
        "*",
        "* Generated by generate_unicode_headers.py from the Unicode Character Database.",
        "*",
        "* See https://www.unicode.org/versions/latest/ for source data.",
        "*/\n",
        "#pragma once\n"
    ]

    for cp in range(start_cp, end_cp + 1):
        name = names.get(cp, f"UNKNOWN_{cp:04X}")
        glyph = printable_glyph(cp)
        comment_parts = [f"U+{cp:04X} ({name})"]
        if glyph:
            comment_parts.append(glyph)

        lines.append(
            f"#define {macro_name_from_unicode_name(name):<40} 0x{cp:04X}   /* {' '.join(comment_parts)} */"
        )

    header_file.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"Written {header_file.relative_to(out_dir)}")

# --------------------------------------------------------------------
# Main ---------------------------------------------------------------
# --------------------------------------------------------------------

def main() -> None:
    # Ensure the data files are present
    blocks_file = get_file("Blocks.txt")          # or Blocks-17.0.0.txt if you prefer
    names_file  = get_file("UnicodeData.txt")

    block_defs = parse_blocks(blocks_file)
    name_map   = load_names(names_file)

    out_dir = pathlib.Path("generated_headers")
    out_dir.mkdir(exist_ok=True)

    for block_name, start, end in block_defs:
        emit_header(block_name, start, end, name_map, out_dir)

    print("\nAll headers written to", out_dir.resolve())

if __name__ == "__main__":
    main()

